// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package util

import (
	"bytes"
	"time"

	mock "github.com/stretchr/testify/mock"
)

// NewMockIUtil creates a new instance of MockIUtil. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockIUtil(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockIUtil {
	mock := &MockIUtil{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockIUtil is an autogenerated mock type for the IUtil type
type MockIUtil struct {
	mock.Mock
}

type MockIUtil_Expecter struct {
	mock *mock.Mock
}

func (_m *MockIUtil) EXPECT() *MockIUtil_Expecter {
	return &MockIUtil_Expecter{mock: &_m.Mock}
}

// CheckFromAndToDateValid provides a mock function for the type MockIUtil
func (_mock *MockIUtil) CheckFromAndToDateValid(from time.Time, to time.Time, isAllowZero bool) (bool, error) {
	ret := _mock.Called(from, to, isAllowZero)

	if len(ret) == 0 {
		panic("no return value specified for CheckFromAndToDateValid")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(time.Time, time.Time, bool) (bool, error)); ok {
		return returnFunc(from, to, isAllowZero)
	}
	if returnFunc, ok := ret.Get(0).(func(time.Time, time.Time, bool) bool); ok {
		r0 = returnFunc(from, to, isAllowZero)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(time.Time, time.Time, bool) error); ok {
		r1 = returnFunc(from, to, isAllowZero)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIUtil_CheckFromAndToDateValid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckFromAndToDateValid'
type MockIUtil_CheckFromAndToDateValid_Call struct {
	*mock.Call
}

// CheckFromAndToDateValid is a helper method to define mock.On call
//   - from time.Time
//   - to time.Time
//   - isAllowZero bool
func (_e *MockIUtil_Expecter) CheckFromAndToDateValid(from interface{}, to interface{}, isAllowZero interface{}) *MockIUtil_CheckFromAndToDateValid_Call {
	return &MockIUtil_CheckFromAndToDateValid_Call{Call: _e.mock.On("CheckFromAndToDateValid", from, to, isAllowZero)}
}

func (_c *MockIUtil_CheckFromAndToDateValid_Call) Run(run func(from time.Time, to time.Time, isAllowZero bool)) *MockIUtil_CheckFromAndToDateValid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 time.Time
		if args[0] != nil {
			arg0 = args[0].(time.Time)
		}
		var arg1 time.Time
		if args[1] != nil {
			arg1 = args[1].(time.Time)
		}
		var arg2 bool
		if args[2] != nil {
			arg2 = args[2].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIUtil_CheckFromAndToDateValid_Call) Return(isOk bool, err error) *MockIUtil_CheckFromAndToDateValid_Call {
	_c.Call.Return(isOk, err)
	return _c
}

func (_c *MockIUtil_CheckFromAndToDateValid_Call) RunAndReturn(run func(from time.Time, to time.Time, isAllowZero bool) (bool, error)) *MockIUtil_CheckFromAndToDateValid_Call {
	_c.Call.Return(run)
	return _c
}

// ConvertMillisToTimeString provides a mock function for the type MockIUtil
func (_mock *MockIUtil) ConvertMillisToTimeString(millis int) string {
	ret := _mock.Called(millis)

	if len(ret) == 0 {
		panic("no return value specified for ConvertMillisToTimeString")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func(int) string); ok {
		r0 = returnFunc(millis)
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockIUtil_ConvertMillisToTimeString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConvertMillisToTimeString'
type MockIUtil_ConvertMillisToTimeString_Call struct {
	*mock.Call
}

// ConvertMillisToTimeString is a helper method to define mock.On call
//   - millis int
func (_e *MockIUtil_Expecter) ConvertMillisToTimeString(millis interface{}) *MockIUtil_ConvertMillisToTimeString_Call {
	return &MockIUtil_ConvertMillisToTimeString_Call{Call: _e.mock.On("ConvertMillisToTimeString", millis)}
}

func (_c *MockIUtil_ConvertMillisToTimeString_Call) Run(run func(millis int)) *MockIUtil_ConvertMillisToTimeString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIUtil_ConvertMillisToTimeString_Call) Return(s string) *MockIUtil_ConvertMillisToTimeString_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockIUtil_ConvertMillisToTimeString_Call) RunAndReturn(run func(millis int) string) *MockIUtil_ConvertMillisToTimeString_Call {
	_c.Call.Return(run)
	return _c
}

// GenerateCodeChallenge provides a mock function for the type MockIUtil
func (_mock *MockIUtil) GenerateCodeChallenge(verifier string) string {
	ret := _mock.Called(verifier)

	if len(ret) == 0 {
		panic("no return value specified for GenerateCodeChallenge")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func(string) string); ok {
		r0 = returnFunc(verifier)
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockIUtil_GenerateCodeChallenge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateCodeChallenge'
type MockIUtil_GenerateCodeChallenge_Call struct {
	*mock.Call
}

// GenerateCodeChallenge is a helper method to define mock.On call
//   - verifier string
func (_e *MockIUtil_Expecter) GenerateCodeChallenge(verifier interface{}) *MockIUtil_GenerateCodeChallenge_Call {
	return &MockIUtil_GenerateCodeChallenge_Call{Call: _e.mock.On("GenerateCodeChallenge", verifier)}
}

func (_c *MockIUtil_GenerateCodeChallenge_Call) Run(run func(verifier string)) *MockIUtil_GenerateCodeChallenge_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIUtil_GenerateCodeChallenge_Call) Return(s string) *MockIUtil_GenerateCodeChallenge_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockIUtil_GenerateCodeChallenge_Call) RunAndReturn(run func(verifier string) string) *MockIUtil_GenerateCodeChallenge_Call {
	_c.Call.Return(run)
	return _c
}

// GenerateCodeVerifier provides a mock function for the type MockIUtil
func (_mock *MockIUtil) GenerateCodeVerifier() (string, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GenerateCodeVerifier")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (string, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIUtil_GenerateCodeVerifier_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateCodeVerifier'
type MockIUtil_GenerateCodeVerifier_Call struct {
	*mock.Call
}

// GenerateCodeVerifier is a helper method to define mock.On call
func (_e *MockIUtil_Expecter) GenerateCodeVerifier() *MockIUtil_GenerateCodeVerifier_Call {
	return &MockIUtil_GenerateCodeVerifier_Call{Call: _e.mock.On("GenerateCodeVerifier")}
}

func (_c *MockIUtil_GenerateCodeVerifier_Call) Run(run func()) *MockIUtil_GenerateCodeVerifier_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockIUtil_GenerateCodeVerifier_Call) Return(s string, err error) *MockIUtil_GenerateCodeVerifier_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockIUtil_GenerateCodeVerifier_Call) RunAndReturn(run func() (string, error)) *MockIUtil_GenerateCodeVerifier_Call {
	_c.Call.Return(run)
	return _c
}

// GenerateRandomString provides a mock function for the type MockIUtil
func (_mock *MockIUtil) GenerateRandomString(n int, letterRunes []rune) string {
	ret := _mock.Called(n, letterRunes)

	if len(ret) == 0 {
		panic("no return value specified for GenerateRandomString")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func(int, []rune) string); ok {
		r0 = returnFunc(n, letterRunes)
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockIUtil_GenerateRandomString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateRandomString'
type MockIUtil_GenerateRandomString_Call struct {
	*mock.Call
}

// GenerateRandomString is a helper method to define mock.On call
//   - n int
//   - letterRunes []rune
func (_e *MockIUtil_Expecter) GenerateRandomString(n interface{}, letterRunes interface{}) *MockIUtil_GenerateRandomString_Call {
	return &MockIUtil_GenerateRandomString_Call{Call: _e.mock.On("GenerateRandomString", n, letterRunes)}
}

func (_c *MockIUtil_GenerateRandomString_Call) Run(run func(n int, letterRunes []rune)) *MockIUtil_GenerateRandomString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		var arg1 []rune
		if args[1] != nil {
			arg1 = args[1].([]rune)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIUtil_GenerateRandomString_Call) Return(s string) *MockIUtil_GenerateRandomString_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockIUtil_GenerateRandomString_Call) RunAndReturn(run func(n int, letterRunes []rune) string) *MockIUtil_GenerateRandomString_Call {
	_c.Call.Return(run)
	return _c
}

// GetEndOfDay provides a mock function for the type MockIUtil
func (_mock *MockIUtil) GetEndOfDay(t time.Time) time.Time {
	ret := _mock.Called(t)

	if len(ret) == 0 {
		panic("no return value specified for GetEndOfDay")
	}

	var r0 time.Time
	if returnFunc, ok := ret.Get(0).(func(time.Time) time.Time); ok {
		r0 = returnFunc(t)
	} else {
		r0 = ret.Get(0).(time.Time)
	}
	return r0
}

// MockIUtil_GetEndOfDay_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEndOfDay'
type MockIUtil_GetEndOfDay_Call struct {
	*mock.Call
}

// GetEndOfDay is a helper method to define mock.On call
//   - t time.Time
func (_e *MockIUtil_Expecter) GetEndOfDay(t interface{}) *MockIUtil_GetEndOfDay_Call {
	return &MockIUtil_GetEndOfDay_Call{Call: _e.mock.On("GetEndOfDay", t)}
}

func (_c *MockIUtil_GetEndOfDay_Call) Run(run func(t time.Time)) *MockIUtil_GetEndOfDay_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 time.Time
		if args[0] != nil {
			arg0 = args[0].(time.Time)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIUtil_GetEndOfDay_Call) Return(time1 time.Time) *MockIUtil_GetEndOfDay_Call {
	_c.Call.Return(time1)
	return _c
}

func (_c *MockIUtil_GetEndOfDay_Call) RunAndReturn(run func(t time.Time) time.Time) *MockIUtil_GetEndOfDay_Call {
	_c.Call.Return(run)
	return _c
}

// HandleCSVStreamWriter provides a mock function for the type MockIUtil
func (_mock *MockIUtil) HandleCSVStreamWriter(fileName string, headers [][]string, rows [][]string, mergedColumns ...string) (*bytes.Buffer, error) {
	var tmpRet mock.Arguments
	if len(mergedColumns) > 0 {
		tmpRet = _mock.Called(fileName, headers, rows, mergedColumns)
	} else {
		tmpRet = _mock.Called(fileName, headers, rows)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for HandleCSVStreamWriter")
	}

	var r0 *bytes.Buffer
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, [][]string, [][]string, ...string) (*bytes.Buffer, error)); ok {
		return returnFunc(fileName, headers, rows, mergedColumns...)
	}
	if returnFunc, ok := ret.Get(0).(func(string, [][]string, [][]string, ...string) *bytes.Buffer); ok {
		r0 = returnFunc(fileName, headers, rows, mergedColumns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bytes.Buffer)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, [][]string, [][]string, ...string) error); ok {
		r1 = returnFunc(fileName, headers, rows, mergedColumns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIUtil_HandleCSVStreamWriter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HandleCSVStreamWriter'
type MockIUtil_HandleCSVStreamWriter_Call struct {
	*mock.Call
}

// HandleCSVStreamWriter is a helper method to define mock.On call
//   - fileName string
//   - headers [][]string
//   - rows [][]string
//   - mergedColumns ...string
func (_e *MockIUtil_Expecter) HandleCSVStreamWriter(fileName interface{}, headers interface{}, rows interface{}, mergedColumns ...interface{}) *MockIUtil_HandleCSVStreamWriter_Call {
	return &MockIUtil_HandleCSVStreamWriter_Call{Call: _e.mock.On("HandleCSVStreamWriter",
		append([]interface{}{fileName, headers, rows}, mergedColumns...)...)}
}

func (_c *MockIUtil_HandleCSVStreamWriter_Call) Run(run func(fileName string, headers [][]string, rows [][]string, mergedColumns ...string)) *MockIUtil_HandleCSVStreamWriter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 [][]string
		if args[1] != nil {
			arg1 = args[1].([][]string)
		}
		var arg2 [][]string
		if args[2] != nil {
			arg2 = args[2].([][]string)
		}
		var arg3 []string
		var variadicArgs []string
		if len(args) > 3 {
			variadicArgs = args[3].([]string)
		}
		arg3 = variadicArgs
		run(
			arg0,
			arg1,
			arg2,
			arg3...,
		)
	})
	return _c
}

func (_c *MockIUtil_HandleCSVStreamWriter_Call) Return(buffer *bytes.Buffer, err error) *MockIUtil_HandleCSVStreamWriter_Call {
	_c.Call.Return(buffer, err)
	return _c
}

func (_c *MockIUtil_HandleCSVStreamWriter_Call) RunAndReturn(run func(fileName string, headers [][]string, rows [][]string, mergedColumns ...string) (*bytes.Buffer, error)) *MockIUtil_HandleCSVStreamWriter_Call {
	_c.Call.Return(run)
	return _c
}

// HandleExcelStreamWriter provides a mock function for the type MockIUtil
func (_mock *MockIUtil) HandleExcelStreamWriter(headers [][]string, rows [][]string, mergedColumns ...string) (*bytes.Buffer, error) {
	var tmpRet mock.Arguments
	if len(mergedColumns) > 0 {
		tmpRet = _mock.Called(headers, rows, mergedColumns)
	} else {
		tmpRet = _mock.Called(headers, rows)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for HandleExcelStreamWriter")
	}

	var r0 *bytes.Buffer
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([][]string, [][]string, ...string) (*bytes.Buffer, error)); ok {
		return returnFunc(headers, rows, mergedColumns...)
	}
	if returnFunc, ok := ret.Get(0).(func([][]string, [][]string, ...string) *bytes.Buffer); ok {
		r0 = returnFunc(headers, rows, mergedColumns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bytes.Buffer)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([][]string, [][]string, ...string) error); ok {
		r1 = returnFunc(headers, rows, mergedColumns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIUtil_HandleExcelStreamWriter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HandleExcelStreamWriter'
type MockIUtil_HandleExcelStreamWriter_Call struct {
	*mock.Call
}

// HandleExcelStreamWriter is a helper method to define mock.On call
//   - headers [][]string
//   - rows [][]string
//   - mergedColumns ...string
func (_e *MockIUtil_Expecter) HandleExcelStreamWriter(headers interface{}, rows interface{}, mergedColumns ...interface{}) *MockIUtil_HandleExcelStreamWriter_Call {
	return &MockIUtil_HandleExcelStreamWriter_Call{Call: _e.mock.On("HandleExcelStreamWriter",
		append([]interface{}{headers, rows}, mergedColumns...)...)}
}

func (_c *MockIUtil_HandleExcelStreamWriter_Call) Run(run func(headers [][]string, rows [][]string, mergedColumns ...string)) *MockIUtil_HandleExcelStreamWriter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 [][]string
		if args[0] != nil {
			arg0 = args[0].([][]string)
		}
		var arg1 [][]string
		if args[1] != nil {
			arg1 = args[1].([][]string)
		}
		var arg2 []string
		var variadicArgs []string
		if len(args) > 2 {
			variadicArgs = args[2].([]string)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockIUtil_HandleExcelStreamWriter_Call) Return(buffer *bytes.Buffer, err error) *MockIUtil_HandleExcelStreamWriter_Call {
	_c.Call.Return(buffer, err)
	return _c
}

func (_c *MockIUtil_HandleExcelStreamWriter_Call) RunAndReturn(run func(headers [][]string, rows [][]string, mergedColumns ...string) (*bytes.Buffer, error)) *MockIUtil_HandleExcelStreamWriter_Call {
	_c.Call.Return(run)
	return _c
}

// MustParseAnyToString provides a mock function for the type MockIUtil
func (_mock *MockIUtil) MustParseAnyToString(value any) string {
	ret := _mock.Called(value)

	if len(ret) == 0 {
		panic("no return value specified for MustParseAnyToString")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func(any) string); ok {
		r0 = returnFunc(value)
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockIUtil_MustParseAnyToString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MustParseAnyToString'
type MockIUtil_MustParseAnyToString_Call struct {
	*mock.Call
}

// MustParseAnyToString is a helper method to define mock.On call
//   - value any
func (_e *MockIUtil_Expecter) MustParseAnyToString(value interface{}) *MockIUtil_MustParseAnyToString_Call {
	return &MockIUtil_MustParseAnyToString_Call{Call: _e.mock.On("MustParseAnyToString", value)}
}

func (_c *MockIUtil_MustParseAnyToString_Call) Run(run func(value any)) *MockIUtil_MustParseAnyToString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 any
		if args[0] != nil {
			arg0 = args[0].(any)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIUtil_MustParseAnyToString_Call) Return(s string) *MockIUtil_MustParseAnyToString_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockIUtil_MustParseAnyToString_Call) RunAndReturn(run func(value any) string) *MockIUtil_MustParseAnyToString_Call {
	_c.Call.Return(run)
	return _c
}

// ParseAnyToAny provides a mock function for the type MockIUtil
func (_mock *MockIUtil) ParseAnyToAny(value any, dest any) error {
	ret := _mock.Called(value, dest)

	if len(ret) == 0 {
		panic("no return value specified for ParseAnyToAny")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(any, any) error); ok {
		r0 = returnFunc(value, dest)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockIUtil_ParseAnyToAny_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseAnyToAny'
type MockIUtil_ParseAnyToAny_Call struct {
	*mock.Call
}

// ParseAnyToAny is a helper method to define mock.On call
//   - value any
//   - dest any
func (_e *MockIUtil_Expecter) ParseAnyToAny(value interface{}, dest interface{}) *MockIUtil_ParseAnyToAny_Call {
	return &MockIUtil_ParseAnyToAny_Call{Call: _e.mock.On("ParseAnyToAny", value, dest)}
}

func (_c *MockIUtil_ParseAnyToAny_Call) Run(run func(value any, dest any)) *MockIUtil_ParseAnyToAny_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 any
		if args[0] != nil {
			arg0 = args[0].(any)
		}
		var arg1 any
		if args[1] != nil {
			arg1 = args[1].(any)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIUtil_ParseAnyToAny_Call) Return(err error) *MockIUtil_ParseAnyToAny_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockIUtil_ParseAnyToAny_Call) RunAndReturn(run func(value any, dest any) error) *MockIUtil_ParseAnyToAny_Call {
	_c.Call.Return(run)
	return _c
}

// ParseAnyToString provides a mock function for the type MockIUtil
func (_mock *MockIUtil) ParseAnyToString(value any) (string, error) {
	ret := _mock.Called(value)

	if len(ret) == 0 {
		panic("no return value specified for ParseAnyToString")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(any) (string, error)); ok {
		return returnFunc(value)
	}
	if returnFunc, ok := ret.Get(0).(func(any) string); ok {
		r0 = returnFunc(value)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(any) error); ok {
		r1 = returnFunc(value)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIUtil_ParseAnyToString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseAnyToString'
type MockIUtil_ParseAnyToString_Call struct {
	*mock.Call
}

// ParseAnyToString is a helper method to define mock.On call
//   - value any
func (_e *MockIUtil_Expecter) ParseAnyToString(value interface{}) *MockIUtil_ParseAnyToString_Call {
	return &MockIUtil_ParseAnyToString_Call{Call: _e.mock.On("ParseAnyToString", value)}
}

func (_c *MockIUtil_ParseAnyToString_Call) Run(run func(value any)) *MockIUtil_ParseAnyToString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 any
		if args[0] != nil {
			arg0 = args[0].(any)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIUtil_ParseAnyToString_Call) Return(s string, err error) *MockIUtil_ParseAnyToString_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockIUtil_ParseAnyToString_Call) RunAndReturn(run func(value any) (string, error)) *MockIUtil_ParseAnyToString_Call {
	_c.Call.Return(run)
	return _c
}

// ParseFloat64 provides a mock function for the type MockIUtil
func (_mock *MockIUtil) ParseFloat64(value any) float64 {
	ret := _mock.Called(value)

	if len(ret) == 0 {
		panic("no return value specified for ParseFloat64")
	}

	var r0 float64
	if returnFunc, ok := ret.Get(0).(func(any) float64); ok {
		r0 = returnFunc(value)
	} else {
		r0 = ret.Get(0).(float64)
	}
	return r0
}

// MockIUtil_ParseFloat64_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseFloat64'
type MockIUtil_ParseFloat64_Call struct {
	*mock.Call
}

// ParseFloat64 is a helper method to define mock.On call
//   - value any
func (_e *MockIUtil_Expecter) ParseFloat64(value interface{}) *MockIUtil_ParseFloat64_Call {
	return &MockIUtil_ParseFloat64_Call{Call: _e.mock.On("ParseFloat64", value)}
}

func (_c *MockIUtil_ParseFloat64_Call) Run(run func(value any)) *MockIUtil_ParseFloat64_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 any
		if args[0] != nil {
			arg0 = args[0].(any)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIUtil_ParseFloat64_Call) Return(f float64) *MockIUtil_ParseFloat64_Call {
	_c.Call.Return(f)
	return _c
}

func (_c *MockIUtil_ParseFloat64_Call) RunAndReturn(run func(value any) float64) *MockIUtil_ParseFloat64_Call {
	_c.Call.Return(run)
	return _c
}

// ParseFloat64With2Decimal provides a mock function for the type MockIUtil
func (_mock *MockIUtil) ParseFloat64With2Decimal(value float64) float64 {
	ret := _mock.Called(value)

	if len(ret) == 0 {
		panic("no return value specified for ParseFloat64With2Decimal")
	}

	var r0 float64
	if returnFunc, ok := ret.Get(0).(func(float64) float64); ok {
		r0 = returnFunc(value)
	} else {
		r0 = ret.Get(0).(float64)
	}
	return r0
}

// MockIUtil_ParseFloat64With2Decimal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseFloat64With2Decimal'
type MockIUtil_ParseFloat64With2Decimal_Call struct {
	*mock.Call
}

// ParseFloat64With2Decimal is a helper method to define mock.On call
//   - value float64
func (_e *MockIUtil_Expecter) ParseFloat64With2Decimal(value interface{}) *MockIUtil_ParseFloat64With2Decimal_Call {
	return &MockIUtil_ParseFloat64With2Decimal_Call{Call: _e.mock.On("ParseFloat64With2Decimal", value)}
}

func (_c *MockIUtil_ParseFloat64With2Decimal_Call) Run(run func(value float64)) *MockIUtil_ParseFloat64With2Decimal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 float64
		if args[0] != nil {
			arg0 = args[0].(float64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIUtil_ParseFloat64With2Decimal_Call) Return(f float64) *MockIUtil_ParseFloat64With2Decimal_Call {
	_c.Call.Return(f)
	return _c
}

func (_c *MockIUtil_ParseFloat64With2Decimal_Call) RunAndReturn(run func(value float64) float64) *MockIUtil_ParseFloat64With2Decimal_Call {
	_c.Call.Return(run)
	return _c
}

// ParseInt64 provides a mock function for the type MockIUtil
func (_mock *MockIUtil) ParseInt64(value any) int64 {
	ret := _mock.Called(value)

	if len(ret) == 0 {
		panic("no return value specified for ParseInt64")
	}

	var r0 int64
	if returnFunc, ok := ret.Get(0).(func(any) int64); ok {
		r0 = returnFunc(value)
	} else {
		r0 = ret.Get(0).(int64)
	}
	return r0
}

// MockIUtil_ParseInt64_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseInt64'
type MockIUtil_ParseInt64_Call struct {
	*mock.Call
}

// ParseInt64 is a helper method to define mock.On call
//   - value any
func (_e *MockIUtil_Expecter) ParseInt64(value interface{}) *MockIUtil_ParseInt64_Call {
	return &MockIUtil_ParseInt64_Call{Call: _e.mock.On("ParseInt64", value)}
}

func (_c *MockIUtil_ParseInt64_Call) Run(run func(value any)) *MockIUtil_ParseInt64_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 any
		if args[0] != nil {
			arg0 = args[0].(any)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIUtil_ParseInt64_Call) Return(n int64) *MockIUtil_ParseInt64_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *MockIUtil_ParseInt64_Call) RunAndReturn(run func(value any) int64) *MockIUtil_ParseInt64_Call {
	_c.Call.Return(run)
	return _c
}

// ParseString provides a mock function for the type MockIUtil
func (_mock *MockIUtil) ParseString(value any) string {
	ret := _mock.Called(value)

	if len(ret) == 0 {
		panic("no return value specified for ParseString")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func(any) string); ok {
		r0 = returnFunc(value)
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockIUtil_ParseString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseString'
type MockIUtil_ParseString_Call struct {
	*mock.Call
}

// ParseString is a helper method to define mock.On call
//   - value any
func (_e *MockIUtil_Expecter) ParseString(value interface{}) *MockIUtil_ParseString_Call {
	return &MockIUtil_ParseString_Call{Call: _e.mock.On("ParseString", value)}
}

func (_c *MockIUtil_ParseString_Call) Run(run func(value any)) *MockIUtil_ParseString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 any
		if args[0] != nil {
			arg0 = args[0].(any)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIUtil_ParseString_Call) Return(s string) *MockIUtil_ParseString_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockIUtil_ParseString_Call) RunAndReturn(run func(value any) string) *MockIUtil_ParseString_Call {
	_c.Call.Return(run)
	return _c
}

// ParseStringToAny provides a mock function for the type MockIUtil
func (_mock *MockIUtil) ParseStringToAny(value string, dest any) error {
	ret := _mock.Called(value, dest)

	if len(ret) == 0 {
		panic("no return value specified for ParseStringToAny")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, any) error); ok {
		r0 = returnFunc(value, dest)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockIUtil_ParseStringToAny_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseStringToAny'
type MockIUtil_ParseStringToAny_Call struct {
	*mock.Call
}

// ParseStringToAny is a helper method to define mock.On call
//   - value string
//   - dest any
func (_e *MockIUtil_Expecter) ParseStringToAny(value interface{}, dest interface{}) *MockIUtil_ParseStringToAny_Call {
	return &MockIUtil_ParseStringToAny_Call{Call: _e.mock.On("ParseStringToAny", value, dest)}
}

func (_c *MockIUtil_ParseStringToAny_Call) Run(run func(value string, dest any)) *MockIUtil_ParseStringToAny_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 any
		if args[1] != nil {
			arg1 = args[1].(any)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIUtil_ParseStringToAny_Call) Return(err error) *MockIUtil_ParseStringToAny_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockIUtil_ParseStringToAny_Call) RunAndReturn(run func(value string, dest any) error) *MockIUtil_ParseStringToAny_Call {
	_c.Call.Return(run)
	return _c
}

// ParseStringToTime provides a mock function for the type MockIUtil
func (_mock *MockIUtil) ParseStringToTime(t string, timezone ...string) *time.Time {
	var tmpRet mock.Arguments
	if len(timezone) > 0 {
		tmpRet = _mock.Called(t, timezone)
	} else {
		tmpRet = _mock.Called(t)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ParseStringToTime")
	}

	var r0 *time.Time
	if returnFunc, ok := ret.Get(0).(func(string, ...string) *time.Time); ok {
		r0 = returnFunc(t, timezone...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*time.Time)
		}
	}
	return r0
}

// MockIUtil_ParseStringToTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseStringToTime'
type MockIUtil_ParseStringToTime_Call struct {
	*mock.Call
}

// ParseStringToTime is a helper method to define mock.On call
//   - t string
//   - timezone ...string
func (_e *MockIUtil_Expecter) ParseStringToTime(t interface{}, timezone ...interface{}) *MockIUtil_ParseStringToTime_Call {
	return &MockIUtil_ParseStringToTime_Call{Call: _e.mock.On("ParseStringToTime",
		append([]interface{}{t}, timezone...)...)}
}

func (_c *MockIUtil_ParseStringToTime_Call) Run(run func(t string, timezone ...string)) *MockIUtil_ParseStringToTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []string
		var variadicArgs []string
		if len(args) > 1 {
			variadicArgs = args[1].([]string)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockIUtil_ParseStringToTime_Call) Return(time1 *time.Time) *MockIUtil_ParseStringToTime_Call {
	_c.Call.Return(time1)
	return _c
}

func (_c *MockIUtil_ParseStringToTime_Call) RunAndReturn(run func(t string, timezone ...string) *time.Time) *MockIUtil_ParseStringToTime_Call {
	_c.Call.Return(run)
	return _c
}
